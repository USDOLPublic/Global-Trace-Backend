import { trans } from '@diginexhk/nestjs-cls-translation';
import { StorageService, generateUniqueName } from '@diginexhk/nestjs-storage';
import { TransactionService } from '@diginexhk/nestjs-transaction';
import { BadRequestException, Injectable, StreamableFile } from '@nestjs/common';
import { CellValue, Row, Workbook, Worksheet } from 'exceljs';
import { readFileSync } from 'fs';
import Joi from 'joi';
import { Dictionary, cloneDeep, get, groupBy, isEmpty, keyBy, trim, uniqBy } from 'lodash';
import path from 'path';
import { Readable } from 'stream';
import { IsNull } from 'typeorm';
import { CategoryEntity } from '~categories/entities/category.entity';
import { CategoryTypeEnum } from '~categories/enums/category-type.enum';
import { CategoryRepository } from '~categories/repositories/category.repository';
import { env } from '~config/env.config';
import { ErrorTypeEnum } from '~files/enums/error-type.enum';
import { UploadTaxonomyExploitationActionEnum } from '~files/enums/upload-taxonomy-of-exploitation-action.enum';
import { addErrorValidation } from '~files/helpers/add-error-validation.helper';
import { initWorkbook } from '~files/helpers/file.helper';
import { checkIfBlankRow } from '~files/helpers/is-blank-row.helper';
import { UploadTemplateResponse } from '~files/http/response/upload-template.response';
import { FileDataValidationType } from '~files/types/file-data-validation.type';
import { WorkBookInitialization } from '~files/types/work-book-initialization.type';
import { LocationService } from '~locations/services/location.service';
import { BusinessDetailRepository } from '~site-details/repositories/business-detail.repository';
import {
    SHEET_1_HEADER_KEYS,
    SHEET_1_HEADER_NAMES,
    SHEET_1_TEMPLATE_HEADERS
} from '~taxonomy-exploitations/constants/taxonomy-exploitation.constants';
import { TaxonomyExploitationFileEntity } from '~taxonomy-exploitations/entities/taxonomy-exploitation-file.entity';
import { RiskSeverityEnum } from '~taxonomy-exploitations/enums/risk-severity.enum';
import { UploadTaxonomyExploitationInterface } from '~taxonomy-exploitations/interfaces/upload-taxonomy-exploitation-template.interface';
import { TaxonomyExploitationFileRepository } from '~taxonomy-exploitations/repositories/taxonomy-exploitation-file.repository';
import { FileTaxonomyExploitationValidation } from '~taxonomy-exploitations/types/file-taxonomy-exploitation-validation.type';
import { TaxonomyExploitationRowValidationResultType } from '~taxonomy-exploitations/types/taxonomy-exploitation-row-validation-result.type';
import { TaxonomyExploitationValidationParams } from '~taxonomy-exploitations/types/taxonomy-exploitation-validation-params.type';

@Injectable()
export class TaxonomyExploitationUploadService extends TransactionService {
    public constructor(
        private taxonomyExploitationFileRepo: TaxonomyExploitationFileRepository,
        private businessDetailRepo: BusinessDetailRepository,
        private storageService: StorageService,
        private categoryRepo: CategoryRepository,
        private locationService: LocationService
    ) {
        super();
    }

    /* eslint-disable @typescript-eslint/naming-convention */
    // eslint-disable-next-line max-lines-per-function
    get schema() {
        return Joi.object({
            country: Joi.string()
                .max(255)
                .required()
                .messages({
                    'string.base': trans('import.invalid_country'),
                    'string.empty': trans('import.require_country'),
                    'string.max': trans('import.max_length_country')
                }),
            sector: Joi.string()
                .max(255)
                .required()
                .messages({
                    'string.base': trans('import.invalid_sector'),
                    'string.empty': trans('import.require_sector'),
                    'string.max': trans('import.max_length_sector')
                }),
            category: Joi.string()
                .max(255)
                .required()
                .messages({
                    'string.base': trans('import.invalid_category'),
                    'string.empty': trans('import.require_category'),
                    'string.max': trans('import.max_length_category')
                }),
            indicator: Joi.string()
                .max(1000)
                .required()
                .messages({
                    'string.base': trans('import.invalid_indicator'),
                    'string.empty': trans('import.require_indicator'),
                    'string.max': trans('import.max_length_indicator')
                }),
            subIndicator: Joi.string()
                .max(1000)
                .required()
                .messages({
                    'string.base': trans('import.invalid_sub_indicator'),
                    'string.empty': trans('import.require_sub_indicator'),
                    'string.max': trans('import.max_length_sub_indicator')
                }),
            severity: Joi.number()
                .required()
                .valid(...Object.values(RiskSeverityEnum))
                .messages({
                    'any.only': trans('import.invalid_severity'),
                    'number.base': trans('import.severity_must_be_number'),
                    'number.empty': trans('import.require_severity')
                }),
            isBlankRow: Joi.boolean()
        });
    }
    /* eslint-enable @typescript-eslint/naming-convention */

    async getUploadTemplate(): Promise<StreamableFile> {
        const templatePath = 'taxonomy-exploitations/templates/Taxonomy of exploitation_template.xlsx';
        const templateBuffer: Buffer = readFileSync(path.join(env.ROOT_PATH, templatePath));

        return new StreamableFile(templateBuffer);
    }

    async uploadAndValidateTemplateData(file: Express.Multer.File): Promise<UploadTemplateResponse> {
        const { workbook, worksheet } = await this.initWorkbook(file);
        const data = this.extractFileData(worksheet);
        const { totalItems, validatedItemCount, validationErrors } = await this.validate(data, worksheet);
        const uploadedFile = await this.uploadFile(file, workbook, !!!validationErrors.length);

        return { fileId: uploadedFile.id, totalItems, validatedItemCount, validationErrors };
    }

    private async initWorkbook(
        fileOrStream: Express.Multer.File | NodeJS.ReadableStream
    ): Promise<WorkBookInitialization> {
        const workbook = await initWorkbook(fileOrStream);
        if (!workbook.worksheets.length) {
            throw new BadRequestException({ translate: 'error.incorrect_format_upload' });
        }
        const worksheet = workbook.worksheets[0];
        this.validHeaderFileUpload(worksheet);
        worksheet.columns = cloneDeep(SHEET_1_TEMPLATE_HEADERS);

        return { workbook, worksheet };
    }

    private validHeaderFileUpload(worksheet: Worksheet) {
        const sheetHeaders = worksheet.getRow(1);
        let key = 1;
        for (const value of Object.values(SHEET_1_HEADER_NAMES)) {
            if (sheetHeaders.getCell(key).value !== value) {
                throw new BadRequestException({ translate: 'error.incorrect_format_upload' });
            }
            key++;
        }
    }

    private extractFileData(worksheet: Worksheet, isTakeValidatedData: boolean = false) {
        const reportData: UploadTaxonomyExploitationInterface<CellValue>[] = [];
        worksheet.eachRow({ includeEmpty: false }, (row, rowNumber) => {
            const isValidated = isTakeValidatedData
                ? worksheet.getRow(rowNumber).getCell(SHEET_1_HEADER_KEYS.IS_VALIDATED)?.toString() === 'true'
                : true;

            if (rowNumber > 1 && isValidated) {
                reportData.push(this.extractRowData(row));
            }
        });

        return reportData;
    }

    private extractRowData(row: Row): UploadTaxonomyExploitationInterface<CellValue> {
        return {
            country: trim(row.getCell(SHEET_1_HEADER_KEYS.COUNTRY).toString()),
            sector: trim(row.getCell(SHEET_1_HEADER_KEYS.SECTOR).toString()),
            category: trim(row.getCell(SHEET_1_HEADER_KEYS.CATEGORY).toString()),
            indicator: trim(row.getCell(SHEET_1_HEADER_KEYS.INDICATOR).toString()),
            subIndicator: trim(row.getCell(SHEET_1_HEADER_KEYS.SUB_INDICATOR).toString()),
            severity: row.getCell(SHEET_1_HEADER_KEYS.SEVERITY).value,
            isBlankRow: checkIfBlankRow(row, SHEET_1_TEMPLATE_HEADERS)
        };
    }

    private setRowData(
        worksheet: Worksheet,
        rowIndex: number,
        cellIndexOrKey: number | string,
        value: CellValue
    ): void {
        worksheet.getRow(rowIndex).getCell(cellIndexOrKey).value = value;
    }

    private validateItems({
        error,
        errors,
        currentRowIndex,
        rowData,
        validatedItemCount,
        worksheet,
        rowIndex,
        isBlankRow
    }: TaxonomyExploitationValidationParams) {
        if (error) {
            addErrorValidation({
                currentListErrors: errors,
                errors: error.details,
                errorType: ErrorTypeEnum.JOI,
                currentRowIndex,
                isBlankRow
            });
        } else {
            validatedItemCount++;
            this.setRowData(worksheet, rowIndex + 2, SHEET_1_HEADER_KEYS.IS_VALIDATED, true);
        }

        return validatedItemCount;
    }

    private async validate(
        fileTemplateData: UploadTaxonomyExploitationInterface<CellValue>[],
        worksheet: Worksheet
    ): Promise<TaxonomyExploitationRowValidationResultType> {
        const errors: FileDataValidationType[] = [];
        let validatedItemCount = 0;

        fileTemplateData.forEach(async (rowData, index) => {
            let currentRowIndex = index + 2;
            const schema = this.schema;
            const { error } = schema.validate(rowData, { abortEarly: false });

            validatedItemCount = this.validateItems({
                error,
                errors,
                currentRowIndex,
                rowData,
                validatedItemCount,
                worksheet,
                rowIndex: +index,
                isBlankRow: rowData.isBlankRow
            });
        });

        const totalItems = fileTemplateData.filter(({ isBlankRow }) => !isBlankRow).length;
        return { totalItems, validatedItemCount, validationErrors: errors };
    }

    async uploadFile(
        file: Express.Multer.File,
        workbook: Workbook,
        isValidated: boolean
    ): Promise<TaxonomyExploitationFileEntity> {
        let blobClient;

        if (file.mimetype === 'text/csv') {
            const buffer = await workbook.csv.writeBuffer();
            const stream = Readable.from(buffer.toString());
            blobClient = await this.storageService.uploadStream(stream, generateUniqueName(file.originalname));
        } else {
            const buffer = await workbook.xlsx.writeBuffer();
            blobClient = await this.storageService.uploadFile({
                file: buffer as Buffer,
                fileName: generateUniqueName(file.originalname)
            });
        }

        return this.taxonomyExploitationFileRepo.createOne({ blobName: blobClient.blobName, isValidated });
    }

    async getFileById(id: string): Promise<NodeJS.ReadableStream> {
        const file = await this.taxonomyExploitationFileRepo.findById(id);
        return this.storageService.getFileStream(file.blobName);
    }

    private async readFileById(id: string): Promise<WorkBookInitialization> {
        const file = await this.taxonomyExploitationFileRepo.findById(id);

        if (!file.isValidated) {
            throw new BadRequestException({ translate: 'error.not_validated_taxonomy_exploitation_upload_file' });
        }

        if (file.isImported) {
            throw new BadRequestException({ translate: 'error.imported_taxonomy_exploitation_upload_file' });
        }

        const fileStream = await this.storageService.getFileStream(file.blobName);

        return this.initWorkbook(fileStream);
    }

    async importTaxonomiesOfExploitation(fileId: string, action: UploadTaxonomyExploitationActionEnum) {
        const { worksheet } = await this.readFileById(fileId);
        const data = this.extractFileData(worksheet, true) as UploadTaxonomyExploitationInterface<string>[];
        const sanitizeData = await this.sanitizeData(data);
        const indicators = groupBy(sanitizeData, 'indicator');
        if (action === UploadTaxonomyExploitationActionEnum.REPLACE) {
            await this.categoryRepo.softDelete({
                deletedAt: IsNull()
            });
        }
        const groupedCategories = groupBy(sanitizeData, 'category');
        const categories = await this.insertCategories(Object.keys(groupedCategories));
        const categoriesKeyName = keyBy(categories, 'name');
        const errors: FileTaxonomyExploitationValidation[] = [];
        for (const indicatorName of Object.keys(indicators)) {
            const groupedSubIndicators = indicators[indicatorName];
            if (action === UploadTaxonomyExploitationActionEnum.REPLACE) {
                await this.saveIndicatorAndSubIndicators(groupedSubIndicators, categoriesKeyName);
                continue;
            }
            const foundIndicator = await this.categoryRepo.findOne({
                where: { name: indicatorName },
                relations: ['subIndicators', 'category']
            });
            if (!foundIndicator) {
                await this.saveIndicatorAndSubIndicators(groupedSubIndicators, categoriesKeyName);
                continue;
            }
            const insertedSubIndicators = groupedSubIndicators.filter(
                ({ subIndicator }) => !!!foundIndicator.subIndicators.find(({ name }) => name === subIndicator)
            );
            await this.insertedSubIndicators(insertedSubIndicators, foundIndicator);
        }
        await this.taxonomyExploitationFileRepo.update(fileId, { isImported: true, action });
        return {
            totalItems: sanitizeData.length,
            validatedItemCount: sanitizeData.length - errors.length,
            validationErrors: errors
        };
    }

    private async sanitizeData(fileTemplateData: UploadTaxonomyExploitationInterface<CellValue>[]) {
        const businessDetail = await this.businessDetailRepo.findOne({ where: {} });
        const countryIds = businessDetail?.countryIds || [];
        const commodities = businessDetail?.commodities || [];
        const countries = !isEmpty(countryIds) ? await this.locationService.findCountryByIds(countryIds) : [];
        const fileTemplateDataFilter = fileTemplateData.reduce(
            (acc: UploadTaxonomyExploitationInterface<CellValue>[], rowData, index) => {
                index += 2;
                const isValidCountry =
                    countries.some(({ country }) => rowData.country === country) || rowData.country === 'All';
                const isValidSector = commodities.includes(rowData.sector.toString()) || rowData.sector === 'All';
                if (isValidCountry && isValidSector) {
                    acc.push({ ...rowData, rowIndex: +index });
                }
                return acc;
            },
            []
        );
        return uniqBy(fileTemplateDataFilter, (rowData) => [rowData.indicator, rowData.subIndicator].join());
    }

    private async insertCategories(categories: string[]) {
        const partialCategories: Partial<CategoryEntity>[] = [];
        const existingCategories = await this.categoryRepo.find({
            where: { type: CategoryTypeEnum.CATEGORY }
        });

        for (const name of categories) {
            const category = existingCategories.find((cate) => cate.name === name);
            if (category) continue;
            partialCategories.push({
                name: name.toString(),
                translation: { en: name.toString() },
                type: CategoryTypeEnum.CATEGORY
            });
        }

        return [...existingCategories, ...(await this.categoryRepo.save(partialCategories))];
    }

    private async saveIndicatorAndSubIndicators(
        groupedSubIndicators: UploadTaxonomyExploitationInterface<CellValue>[],
        categoriesGroupName: Dictionary<CategoryEntity>
    ) {
        const indicatorName = get(groupedSubIndicators[0], 'indicator').toString();
        const categoryName = get(groupedSubIndicators[0], 'category').toString();
        const indicator = await this.categoryRepo.save({
            name: indicatorName,
            translation: { en: indicatorName },
            type: CategoryTypeEnum.INDICATOR,
            categoryId: categoriesGroupName[categoryName].id
        });
        indicator.category = categoriesGroupName[categoryName];
        await this.insertedSubIndicators(groupedSubIndicators, indicator);
    }

    private insertedSubIndicators(
        insertedSubIndicator: UploadTaxonomyExploitationInterface<CellValue>[],
        foundIndicator: CategoryEntity
    ) {
        return this.categoryRepo.save(
            insertedSubIndicator.map(({ subIndicator, severity }) => ({
                parentId: foundIndicator.id,
                name: subIndicator.toString(),
                translation: { en: subIndicator.toString() },
                type: CategoryTypeEnum.SUB_INDICATOR,
                category: foundIndicator.category,
                riskSeverity: +severity,
                categoryId: foundIndicator.category.id
            }))
        );
    }
}
