/* eslint-disable @typescript-eslint/naming-convention */
import { PaginationParams, SortMultipleParams } from '@diginexhk/nestjs-base-decorator';
import { trans } from '@diginexhk/nestjs-cls-translation';
import { ValidateException } from '@diginexhk/nestjs-exception';
import { TransactionService } from '@diginexhk/nestjs-transaction';
import { PaginationCollection } from '@diginexhk/typeorm-helper';
import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import Joi from 'joi';
import { Not } from 'typeorm';
import { CategoryEntity } from '~categories/entities/category.entity';
import { CategoryTypeEnum } from '~categories/enums/category-type.enum';
import { CategoryRepository } from '~categories/repositories/category.repository';
import { CategoryService } from '~categories/services/category.service';
import { generatePaginateCollection } from '~core/helpers/object-helper';
import { isUuidV4 } from '~core/helpers/string.helper';
import { addMissingTranslations } from '~core/helpers/translation.helper';
import { ProductTranslationValidationType } from '~product-definitions/types/product-translation-validation-error.type';
import { UpdateTaxonomyExploitationDto } from '~taxonomy-exploitations/http/dto/update-taxonomy-exploitation.dto';
import { TaxonomyExploitationResponse } from '~taxonomy-exploitations/http/response/taxonomy-exploitation.response';
import { TaxonomyTranslationResponse } from '~taxonomy-exploitations/http/response/taxonomy-translation.response';
import { TranslateTaxonomyResponse } from '~taxonomy-exploitations/http/response/translate-taxonomy.repsonse';
import { GetAndSearchTaxonomyExploitationQuery } from '~taxonomy-exploitations/queries/get-and-search-taxonomy-exploitation.query';
import { TaxonomyExploitationType } from '~taxonomy-exploitations/types/taxonomy-exploitation.type';

@Injectable()
export class TaxonomyExploitationService extends TransactionService {
    public constructor(private categoryRepo: CategoryRepository, private categoryService: CategoryService) {
        super();
    }

    async getAllTaxonomyExploitations(
        sortParams: SortMultipleParams[],
        pagination: PaginationParams,
        key?: string
    ): Promise<PaginationCollection<TaxonomyExploitationType>> {
        const collection = await this.categoryRepo.pagination(
            new GetAndSearchTaxonomyExploitationQuery({ key, sortParams }),
            pagination
        );

        const categories = collection.items.map((category) => this.createTaxonomyExploitationResponse(category));

        return generatePaginateCollection(pagination, collection.total, categories);
    }

    async getTaxonomyExploitation(indicatorId: string, subIndicatorId: string): Promise<TaxonomyExploitationResponse> {
        const category = await this.categoryRepo.findOneOrFail({
            where: {
                id: subIndicatorId,
                parentId: indicatorId
            },
            relations: ['indicator']
        });

        return this.createTaxonomyExploitationResponse(category);
    }

    private createTaxonomyExploitationResponse(categoryItem: CategoryEntity) {
        const { indicator, category, ...rest } = categoryItem;

        return {
            ...indicator,
            category,
            subIndicator: rest
        };
    }

    // eslint-disable-next-line max-lines-per-function
    private async validateUpdateTaxonomyExploitationData(
        indicatorId: string,
        subIndicatorId: string,
        data: UpdateTaxonomyExploitationDto
    ) {
        const [foundIndicator, foundSubIndicator, taxonomyExploitation] = await Promise.all([
            this.categoryRepo.findOne({ where: { id: indicatorId } }),
            this.categoryRepo.findOne({ where: { id: subIndicatorId } }),
            this.categoryRepo.findOneBy({ id: subIndicatorId, parentId: indicatorId })
        ]);

        if (!foundIndicator) {
            throw new NotFoundException({ translate: 'error.indicator_id_invalid' });
        }

        if (!foundSubIndicator) {
            throw new NotFoundException({ translate: 'error.sub_indicator_id_invalid' });
        }

        if (!taxonomyExploitation) {
            throw new NotFoundException({ translate: 'error.taxonomy_exploitation_not_found' });
        }

        const existedSubIndicator = await this.categoryRepo.findOne({
            where: {
                id: Not(subIndicatorId),
                name: data.subIndicatorName,
                parentId: indicatorId,
                type: CategoryTypeEnum.SUB_INDICATOR
            }
        });
        if (existedSubIndicator) {
            throw new ValidateException([
                {
                    property: 'subIndicatorName',
                    constraints: {
                        invalidField: {
                            message: 'existed_sub_indicator_name',
                            detail: {}
                        } as any
                    }
                }
            ]);
        }
    }

    async updateTaxonomyExploitation(indicatorId: string, subIndicatorId: string, data: UpdateTaxonomyExploitationDto) {
        const { category, indicatorName, subIndicatorName, riskSeverity } = data;
        await this.validateUpdateTaxonomyExploitationData(indicatorId, subIndicatorId, data);

        const [indicator, subIndicator] = await Promise.all([
            this.categoryService.findOneBy({ type: CategoryTypeEnum.INDICATOR, id: indicatorId }),
            this.categoryService.findOneBy({ type: CategoryTypeEnum.SUB_INDICATOR, id: subIndicatorId })
        ]);

        const updateSubIndicator: Partial<CategoryEntity> = { riskSeverity };
        if (subIndicator.name !== subIndicatorName) {
            updateSubIndicator.name = subIndicatorName;
            updateSubIndicator.translation = { en: subIndicatorName };
        }
        await this.categoryService.update(subIndicatorId, updateSubIndicator);

        let newCategory = await this.categoryRepo.findOne({ where: { name: category } });
        if (!newCategory) {
            newCategory = await this.categoryService.createOne({
                name: category,
                translation: { en: category },
                type: CategoryTypeEnum.CATEGORY
            });
        }
        let newIndicator = await this.categoryRepo.findOne({
            where: { name: indicatorName, categoryId: newCategory.id }
        });
        if (!newIndicator) {
            newIndicator = await this.categoryService.createOne({
                ...indicator.clone(),
                name: indicatorName,
                translation: { en: indicatorName },
                categoryId: newCategory.id
            });
        }
        await this.categoryService.update(subIndicatorId, { parentId: newIndicator.id, categoryId: newCategory.id });
    }

    async deleteTaxonomyExploitation(indicatorId: string, subIndicatorId: string) {
        await this.categoryRepo.softDelete(subIndicatorId);

        const category = await this.categoryRepo.findOne({
            where: {
                parentId: indicatorId,
                type: CategoryTypeEnum.SUB_INDICATOR
            }
        });

        if (!category) {
            await this.categoryRepo.softDelete(indicatorId);
        }
    }

    async getTaxonomyTranslations(): Promise<CategoryEntity[]> {
        const categories = await this.categoryRepo.find({ select: ['id', 'name', 'translation'] });
        for (let i = 0; i < categories.length; i++) {
            categories[i]['index'] = i;
        }
        return addMissingTranslations(categories, 'translation');
    }

    async translateTaxonomy(file: Express.Multer.File): Promise<TranslateTaxonomyResponse> {
        const taxonomyTranslations = this.readTaxonomyTranslationJsonFile(file);
        if (!Array.isArray(taxonomyTranslations) || !taxonomyTranslations?.length) {
            throw new BadRequestException({ translate: 'error.invalid_taxonomy_translation_file' });
        }

        const validationErrors = await this.validateTaxonomyTranslations(taxonomyTranslations);
        const preparedTaxonomyTranslations = this.prepareUpdateTaxonomyTranslation(
            validationErrors,
            taxonomyTranslations
        );

        return {
            validationErrors,
            updatedTaxonomyTranslations: await this.categoryRepo.save(preparedTaxonomyTranslations)
        };
    }

    private readTaxonomyTranslationJsonFile(file: Express.Multer.File): TaxonomyTranslationResponse[] {
        try {
            return JSON.parse(file.buffer.toString('utf8'));
        } catch (error) {
            throw new BadRequestException({ translate: 'error.invalid_taxonomy_translation_file' });
        }
    }

    private async validateTaxonomyTranslations(
        taxonomyTranslations: TaxonomyTranslationResponse[]
    ): Promise<ProductTranslationValidationType[]> {
        const validationErrors: ProductTranslationValidationType[] = [];
        for (const index in taxonomyTranslations) {
            let errors = [];
            const taxonomyTranslation = taxonomyTranslations[index];
            const { error } = this.taxonomyTranslationSchema.validate(taxonomyTranslation, { abortEarly: false });

            if (error) {
                errors = error.message.split('. ').map((message) => ({
                    key: message.match(/\\?"(.*?)(?<!\\)"/gm)[0].replace(/\"/g, ''),
                    error: message.trim().replace(/\"/g, ''),
                    isShowKey: false
                }));
            }

            if (taxonomyTranslation?.id && isUuidV4(taxonomyTranslation?.id)) {
                const fountItem = await this.categoryRepo.exist({ where: { id: taxonomyTranslation.id } });

                if (!fountItem) {
                    errors.push({ key: 'id', error: 'Invalid id', isShowKey: false });
                }
            }

            if (errors.length) {
                validationErrors.push({
                    errors,
                    index: Number(index),
                    isShowRow: true
                });
            }
        }

        return validationErrors;
    }

    private prepareUpdateTaxonomyTranslation(
        validationErrors: ProductTranslationValidationType[],
        taxonomyTranslations: TaxonomyTranslationResponse[]
    ): TaxonomyTranslationResponse[] {
        const listOfIndexErrors = validationErrors.map(({ index }) => index);

        return taxonomyTranslations.reduce((acc, taxonomyTranslation, index) => {
            if (!listOfIndexErrors.includes(index)) {
                acc.push(taxonomyTranslation);
            }
            return acc;
        }, []);
    }

    private get taxonomyTranslationSchema(): Joi.ObjectSchema<TaxonomyTranslationResponse> {
        return Joi.object({
            id: Joi.string()
                .required()
                .guid()
                .messages({
                    'any.base': trans('import.invalid_id_in_object'),
                    'any.required': trans('import.require_id_in_object'),
                    'string.guid': trans('import.id_must_be_uuid')
                }),
            name: Joi.string()
                .max(255)
                .required()
                .messages({
                    'any.base': trans('import.invalid_name_in_object'),
                    'any.required': trans('import.require_name_in_object')
                }),
            translation: Joi.object()
                .pattern(
                    Joi.string()
                        .pattern(/^[a-z]+$/)
                        .max(255)
                        .required(),
                    Joi.string()
                        .required()
                        .messages({
                            'string.base': trans('import.invalid_language_translation', {
                                args: { languageTranslation: '{{#label}}' }
                            })
                        })
                )
                .messages({
                    'object.base': trans('import.invalid_name_translation')
                }),
            index: Joi.number().optional()
        });
    }
}
