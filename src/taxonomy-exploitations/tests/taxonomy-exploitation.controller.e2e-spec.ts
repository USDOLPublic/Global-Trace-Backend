import assert from 'assert';
import excel from 'exceljs';
import faker from 'faker';
import fs from 'fs';
import { get } from 'lodash';
import path from 'path';
import { CategoryEntity } from '~categories/entities/category.entity';
import { CategoryTypeEnum } from '~categories/enums/category-type.enum';
import { CategoryRepository } from '~categories/repositories/category.repository';
import { env } from '~config/env.config';
import { TestHelper } from '~core/tests/test.helper';
import { UploadTaxonomyExploitationActionEnum } from '~files/enums/upload-taxonomy-of-exploitation-action.enum';
import { UserRoleEnum } from '~role-permissions/enums/user-role.enum';
import { UserEntity } from '~users/entities/user.entity';
import { UserTestHelper } from '~users/tests/user-test.helper';
import { TaxonomyExploitationTestHelper } from './taxonomy-exploitation-test.helper';

describe('TaxonomyExploitationController (e2e)', () => {
    let testHelper = new TestHelper();
    let userTestHelper = testHelper.getTestHelperModule(UserTestHelper);
    let taxonomyExploitationTestHelper = testHelper.getTestHelperModule(TaxonomyExploitationTestHelper);
    let superAdmin: UserEntity;
    let superAdminToken: string;

    async function readSupplierTemplateData() {
        const workbook = new excel.Workbook();
        await workbook.xlsx.readFile(
            path.join(env.ROOT_PATH, `taxonomy-exploitations/tests/assets/taxonomy-of-exploitation.xlsx`)
        );
        let jsonData = [];
        workbook.worksheets.forEach(function (sheet) {
            let firstRow = sheet.getRow(1);
            if (!firstRow.cellCount) return;
            let keys = firstRow.values;
            sheet.eachRow((row, rowNumber) => {
                if (rowNumber == 1) return;
                let values = row.values;
                let obj = {};
                for (let i = 1; i < Number(keys.length); i++) {
                    obj[keys[i]] = values[i];
                }
                jsonData.push(obj);
            });
        });
        return jsonData;
    }

    beforeAll(async () => {
        await testHelper.initialize();
        superAdmin = await userTestHelper.createUser({}, UserRoleEnum.SUPER_ADMIN);
        superAdminToken = await userTestHelper.getToken(superAdmin);
    });

    afterAll(async () => {
        await testHelper.close();
    });

    describe('Super Admin gets all taxonomies of exploitation', () => {
        it('Super Admin gets all taxonomies of exploitation successfully', async () => {
            return testHelper.get('/taxonomy-exploitations').authenticate(superAdminToken).isPagination();
        });

        it('Sort the list of taxonomies of exploitation by indicator:ASC successfully', async () => {
            await taxonomyExploitationTestHelper.createIndicator({ name: 'A' }, [{}]);
            return testHelper
                .get('/taxonomy-exploitations?sortFields=indicator:ASC')
                .authenticate(superAdminToken)
                .isPagination()
                .then(({ body }) => {
                    assert.strictEqual(body.items[0].name, 'A');
                });
        });

        it('Sort the list of taxonomies of exploitation by indicator:DESC successfully', async () => {
            await taxonomyExploitationTestHelper.createIndicator({ name: 'Z' }, [{}]);

            return testHelper
                .get('/taxonomy-exploitations?sortFields=indicator:DESC')
                .authenticate(superAdminToken)
                .isPagination()
                .then(({ body }) => {
                    assert.strictEqual(body.items[0].name, 'Z');
                });
        });

        it('Sort the list of taxonomies of exploitation by subIndicator:ASC successfully', async () => {
            await taxonomyExploitationTestHelper.createIndicator({ name: 'Abusive working and living conditions' }, [
                { name: 'A' }
            ]);

            return testHelper
                .get('/taxonomy-exploitations?sortFields=subIndicator:ASC')
                .authenticate(superAdminToken)
                .isPagination()
                .then(({ body }) => {
                    assert.strictEqual(body.items[0].subIndicator.name, 'A');
                });
        });

        it('Sort the list of taxonomies of exploitation by subIndicator:DESC successfully', async () => {
            await taxonomyExploitationTestHelper.createIndicator({ name: 'Abusive working and living conditions' }, [
                { name: 'Z' }
            ]);

            return testHelper
                .get('/taxonomy-exploitations?sortFields=subIndicator:DESC')
                .authenticate(superAdminToken)
                .isPagination()
                .then(({ body }) => {
                    assert.strictEqual(body.items[0].subIndicator.name, 'Z');
                });
        });

        it('Sort the list of taxonomies of exploitation by category:ASC successfully', async () => {
            return testHelper
                .get('/taxonomy-exploitations?sortFields=category:ASC')
                .authenticate(superAdminToken)
                .isPagination();
        });

        it('Sort the list of taxonomies of exploitation by category:DESC successfully', async () => {
            return testHelper
                .get('/taxonomy-exploitations?sortFields=category:DESC')
                .authenticate(superAdminToken)
                .isPagination();
        });

        it('Sort the list of taxonomies of exploitation by riskSeverity:ASC successfully', async () => {
            return testHelper
                .get('/taxonomy-exploitations?sortFields=riskSeverity:ASC')
                .authenticate(superAdminToken)
                .isPagination();
        });

        it('Sort the list of taxonomies of exploitation by riskSeverity:DESC successfully', async () => {
            return testHelper
                .get('/taxonomy-exploitations?sortFields=riskSeverity:DESC')
                .authenticate(superAdminToken)
                .isPagination();
        });

        it('Search the list of taxonomies of exploitation by name successfully', async () => {
            return testHelper
                .get('/taxonomy-exploitations?key=Abusive working and living conditions')
                .authenticate(superAdminToken)
                .isPagination()
                .then(({ body }) => {
                    assert.strictEqual(body.items[0].name, 'Abusive working and living conditions');
                });
        });
    });

    describe('Super Admin get a taxonomy of exploitation', () => {
        it('View a taxonomy of exploitation successfully', async () => {
            const indicator = await taxonomyExploitationTestHelper.createIndicator({}, [{}]);
            const subIndicator = await CategoryRepository.make().findOneByOrFail({ parentId: indicator.id });

            return testHelper
                .get(`/taxonomy-exploitations/${indicator.id}/sub-indicators/${subIndicator.id}`)
                .authenticate(superAdminToken)
                .isOk()
                .has(['id', 'createdAt', 'updatedAt', 'name', 'categoryId', 'riskSeverity', 'type'])
                .then(({ body }) => {
                    expect(body).toMatchObject({
                        id: indicator.id,
                        subIndicator: {
                            id: subIndicator.id
                        }
                    });
                });
        });
    });

    describe('Super Admin edit a taxonomy of exploitation', () => {
        it('Edit taxonomy of exploitation successfully', async () => {
            const indicator = await taxonomyExploitationTestHelper.createIndicator({}, [
                { name: 'Sub Indicator 1' },
                { name: 'Sub Indicator 2', riskSeverity: 2 }
            ]);
            const subIndicator = await CategoryRepository.make().findOneByOrFail({
                name: 'Sub Indicator 1',
                parentId: indicator.id
            });
            const category = await CategoryRepository.make().findOneByOrFail({
                id: indicator.categoryId
            });

            return testHelper
                .put(`/taxonomy-exploitations/${indicator.id}/sub-indicators/${subIndicator.id}`)
                .authenticate(superAdminToken)
                .send({
                    category: category.name,
                    indicatorName: 'Indicator Name',
                    subIndicatorName: 'Sub-Indicator Name',
                    riskSeverity: 1
                })
                .isNoContent()
                .then(async () => {
                    await subIndicator.reload();

                    await testHelper.visibleInDatabase(CategoryEntity, {
                        id: subIndicator.parentId,
                        name: 'Indicator Name',
                        type: CategoryTypeEnum.INDICATOR,
                        categoryId: subIndicator.categoryId
                    });

                    await testHelper.visibleInDatabase(CategoryEntity, {
                        id: subIndicator.id,
                        name: 'Sub-Indicator Name',
                        type: CategoryTypeEnum.SUB_INDICATOR,
                        categoryId: subIndicator.categoryId,
                        riskSeverity: 1,
                        parentId: subIndicator.parentId
                    });
                });
        });

        it('Edit taxonomy of exploitation failed: Invalid Indicator ID.', async () => {
            return testHelper
                .put(
                    `/taxonomy-exploitations/396bceee-d552-460a-b428-972d40ae0f35/sub-indicators/bf553921-c66a-4664-8fe9-c0187edf36eb`
                )
                .authenticate(superAdminToken)
                .send({
                    category: 'Category',
                    indicatorName: 'Indicator Name',
                    subIndicatorName: 'Sub-Indicator Name',
                    riskSeverity: 1
                })
                .isNotFound()
                .then(({ body: { message } }) => expect(message).toEqual('Indicator ID is invalid'));
        });

        it('Edit taxonomy of exploitation failed: Invalid Sub Indicator ID.', async () => {
            const indicator = await taxonomyExploitationTestHelper.createIndicator({}, [{}]);

            return testHelper
                .put(`/taxonomy-exploitations/${indicator.id}/sub-indicators/59375094-e2e7-4eac-9c3c-0b612840062f`)
                .authenticate(superAdminToken)
                .send({
                    category: 'Category',
                    indicatorName: 'Indicator Name',
                    subIndicatorName: 'Sub-Indicator Name',
                    riskSeverity: 1
                })
                .isNotFound()
                .then(({ body: { message } }) => expect(message).toEqual('Sub Indicator ID is invalid'));
        });

        it('Edit taxonomy of exploitation failed: The sub indicator name has already been taken.', async () => {
            const indicator = await taxonomyExploitationTestHelper.createIndicator({}, [
                { name: 'Sub Indicator 1' },
                { name: 'Sub Indicator 2' }
            ]);
            const subIndicator = await CategoryRepository.make().findOneByOrFail({
                parentId: indicator.id,
                name: 'Sub Indicator 1'
            });

            return (
                testHelper
                    .put(`/taxonomy-exploitations/${indicator.id}/sub-indicators/${subIndicator.id}`)
                    .authenticate(superAdminToken)
                    .send({
                        category: 'Category',
                        indicatorName: faker.random.words(20),
                        subIndicatorName: 'Sub Indicator 2',
                        riskSeverity: 1
                    })
                    .isValidateError()
                    // .has(['errors.subIndicatorName'])
                    .then(({ body }) => {
                        assert.strictEqual(body.message, 'Validate Exception');
                        const message = get(body, 'errors.subIndicatorName.messages[0]');

                        assert.strictEqual(message, 'The sub indicator name has already been taken.');
                    })
            );
        });
    });

    describe('Super Admin delete taxonomy of exploitation', () => {
        it('Delete a sub indicator of an indicator successfully', async () => {
            const indicator = await taxonomyExploitationTestHelper.createIndicator({}, [{}, {}]);
            const subIndicator = await CategoryRepository.make().findOneByOrFail({ parentId: indicator.id });

            await testHelper
                .delete(`/taxonomy-exploitations/${indicator.id}/sub-indicators/${subIndicator.id}`)
                .authenticate(superAdminToken)
                .isNoContent()
                .then(async () => {
                    await testHelper.invisibleInDatabase(CategoryEntity, {
                        id: subIndicator.id
                    });

                    await testHelper.visibleInDatabase(CategoryEntity, {
                        id: indicator.id
                    });
                });
        });

        it('Delete all sub indicators of an indicator successfully', async () => {
            const indicator = await taxonomyExploitationTestHelper.createIndicator({}, [{}]);
            const subIndicator = await CategoryRepository.make().findOneByOrFail({ parentId: indicator.id });

            await testHelper
                .delete(`/taxonomy-exploitations/${indicator.id}/sub-indicators/${subIndicator.id}`)
                .authenticate(superAdminToken)
                .isNoContent()
                .then(async () => {
                    await testHelper.invisibleInDatabase(CategoryEntity, {
                        id: subIndicator.id
                    });

                    await testHelper.invisibleInDatabase(CategoryEntity, {
                        id: indicator.id
                    });
                });
        });
    });

    describe('Super Admin import taxonomies of exploitation', () => {
        const baseUrl = '/taxonomy-exploitations/upload-templates';

        it('Get taxonomy of exploitation template data successfully', async () => {
            let shortToken: string;
            await testHelper
                .post('/auth/short-token')
                .authenticate(superAdminToken)
                .isCreated()
                .then(({ body }) => {
                    expect(body).toHaveProperty('shortToken');
                    shortToken = body.shortToken;
                });

            await testHelper.get(`${baseUrl}?shortToken=${shortToken}`).isOk();
        });

        it('Upload file with correct taxonomy of exploitation template data ', async () => {
            const { body } = await testHelper
                .post(baseUrl)
                .authenticate(superAdminToken)
                .set('Content-Type', 'multipart/form-data')
                .attach(
                    'file',
                    fs.readFileSync(
                        path.join(env.ROOT_PATH, `taxonomy-exploitations/tests/assets/taxonomy-of-exploitation.xlsx`)
                    ),
                    'taxonomy-of-exploitation.xlsx'
                )
                .isCreated();

            expect(body.validatedItemCount).toEqual(1);
        });

        it('Upload file with correct taxonomy of exploitation template data and empty all columns values', async () => {
            const { body } = await testHelper
                .post(baseUrl)
                .authenticate(superAdminToken)
                .set('Content-Type', 'multipart/form-data')
                .attach(
                    'file',
                    fs.readFileSync(
                        path.join(
                            env.ROOT_PATH,
                            `taxonomy-exploitations/tests/assets/empty-taxonomy-of-exploitation.xlsx`
                        )
                    ),
                    'empty-taxonomy-of-exploitation.xlsx'
                )
                .isCreated();

            expect(body.validationErrors).toEqual([]);
            expect(body.validated).toEqual(undefined);
        });

        it('Upload file with correct taxonomy of exploitation template data and empty values in require columns', async () => {
            const { body } = await testHelper
                .post(baseUrl)
                .authenticate(superAdminToken)
                .set('Content-Type', 'multipart/form-data')
                .attach(
                    'file',
                    fs.readFileSync(
                        path.join(
                            env.ROOT_PATH,
                            `taxonomy-exploitations/tests/assets/empty-required-columns-taxonomy-of-exploitation.xlsx`
                        )
                    ),
                    'empty-required-taxonomy-of-exploitation.xlsx'
                )
                .isCreated();

            const errors = body.validationErrors[0].errors;
            expect(errors[0].error).toEqual('Country is required');
            expect(errors[1].error).toEqual('Sector is required');
            expect(errors[2].error).toEqual('Category is required');
            expect(errors[3].error).toEqual('Indicator is required');
            expect(errors[4].error).toEqual('Sub-indicator is required');
        });

        it('Upload file with correct taxonomy of exploitation template data and invalid values in require columns', async () => {
            const { body } = await testHelper
                .post(baseUrl)
                .authenticate(superAdminToken)
                .set('Content-Type', 'multipart/form-data')
                .attach(
                    'file',
                    fs.readFileSync(
                        path.join(
                            env.ROOT_PATH,
                            `taxonomy-exploitations/tests/assets/invalid-required-columns-taxonomy-of-exploitation.xlsx`
                        )
                    ),
                    'invalid-required-taxonomy-of-exploitation.xlsx'
                )
                .isCreated();

            const errors = body.validationErrors[0].errors;
            expect(errors[0].error).toBe('Invalid Severity');
        });

        it('Import taxonomy of exploitation successfully: Replace', async () => {
            await taxonomyExploitationTestHelper.createIndicator({}, [{}, {}]);
            const { body } = await testHelper
                .post(baseUrl)
                .authenticate(superAdminToken)
                .set('Content-Type', 'multipart/form-data')
                .attach(
                    'file',
                    fs.readFileSync(
                        path.join(env.ROOT_PATH, `taxonomy-exploitations/tests/assets/taxonomy-of-exploitation.xlsx`)
                    ),
                    'taxonomy-of-exploitation.xlsx'
                )
                .isCreated();

            let dataFields = await readSupplierTemplateData();
            const indicatorName: string = dataFields[0].Indicator?.toString();
            const subIndicatorName: string = dataFields[0]['Sub-indicator']?.toString();

            await testHelper
                .post(`${baseUrl}/${body.fileId}`)
                .authenticate(superAdminToken)
                .send({ action: UploadTaxonomyExploitationActionEnum.REPLACE })
                .isCreated()
                .then(async () => {
                    const indicator = await CategoryRepository.make().findOne({ where: { name: indicatorName } });
                    const count = await CategoryRepository.make().count();

                    expect(count).toEqual(3);

                    await testHelper.visibleInDatabase(CategoryEntity, {
                        parentId: indicator.id,
                        name: subIndicatorName
                    });
                });
        });

        it('Import taxonomy of exploitation successfully: Add', async () => {
            await taxonomyExploitationTestHelper.createIndicator({}, [{}, {}]);

            const { body } = await testHelper
                .post(baseUrl)
                .authenticate(superAdminToken)
                .set('Content-Type', 'multipart/form-data')
                .attach(
                    'file',
                    fs.readFileSync(
                        path.join(env.ROOT_PATH, `taxonomy-exploitations/tests/assets/taxonomy-of-exploitation.xlsx`)
                    ),
                    'taxonomy-of-exploitation.xlsx'
                )
                .isCreated();

            let dataFields = await readSupplierTemplateData();
            const indicatorName: string = dataFields[0].Indicator?.toString();
            const subIndicatorName: string = dataFields[0]['Sub-indicator']?.toString();

            await testHelper
                .post(`${baseUrl}/${body.fileId}`)
                .authenticate(superAdminToken)
                .send({ action: UploadTaxonomyExploitationActionEnum.ADD })
                .isCreated()
                .then(async () => {
                    const indicator = await CategoryRepository.make().findOne({ where: { name: indicatorName } });
                    const count = await CategoryRepository.make().count();

                    expect(count).toBeGreaterThan(2);

                    await testHelper.visibleInDatabase(CategoryEntity, {
                        parentId: indicator.id,
                        name: subIndicatorName
                    });
                });
        });
    });
});
